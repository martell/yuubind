<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `auto_enums` crate."><meta name="keywords" content="rust, rustlang, rust-lang, auto_enums"><title>auto_enums - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../auto_enums/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate auto_enums</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all auto_enums's items</p></a><p class='location'></p><script>window.sidebarCurrent = {name: 'auto_enums', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/auto_enums/lib.rs.html#1-824' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>auto_enums</a></span></h1><div class='docblock'><p>A library for to allow multiple return types by automatically generated enum.</p>
<p>This library provides the following attribute macros:</p>
<ul>
<li>
<p><code>#[auto_enum]</code></p>
<p>Parses syntax, creates the enum, inserts variants, and passes specified
traits to <code>#[enum_derive]</code>.</p>
</li>
<li>
<p><code>#[enum_derive]</code></p>
<p>Implements specified traits to the enum.</p>
</li>
</ul>
<h2 id="auto_enum" class="section-header"><a href="#auto_enum"><code>#[auto_enum]</code></a></h2>
<p><code>#[auto_enum]</code>'s basic feature is to wrap the value returned by the obvious
branches (<code>match</code>, <code>if</code>, <code>return</code>, etc..) by an enum that implemented the
specified traits.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">1</span>..<span class="number">10</span>,
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    }
}</pre></div>
<p><code>#[auto_enum]</code> generates code in two stages.</p>
<p>First, <code>#[auto_enum]</code> will do the following.</p>
<ul>
<li>parses syntax</li>
<li>creates the enum</li>
<li>inserts variants</li>
</ul>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[::<span class="ident">auto_enums</span>::<span class="ident">enum_derive</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">enum</span> <span class="ident">__Enum1</span><span class="op">&lt;</span><span class="ident">__T1</span>, <span class="ident">__T2</span><span class="op">&gt;</span> {
        <span class="ident">__T1</span>(<span class="ident">__T1</span>),
        <span class="ident">__T2</span>(<span class="ident">__T2</span>),
    }

    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">__Enum1</span>::<span class="ident">__T1</span>(<span class="number">1</span>..<span class="number">10</span>),
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">__Enum1</span>::<span class="ident">__T2</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>()),
    }
}</pre></div>
<p>Next, <code>#[enum_derive]</code> implements the specified traits.</p>
<details>
<summary>Code like this will be generated:</summary>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">enum</span> <span class="ident">__Enum1</span><span class="op">&lt;</span><span class="ident">__T1</span>, <span class="ident">__T2</span><span class="op">&gt;</span> {
        <span class="ident">__T1</span>(<span class="ident">__T1</span>),
        <span class="ident">__T2</span>(<span class="ident">__T2</span>),
    }

    <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">__T1</span>, <span class="ident">__T2</span><span class="op">&gt;</span> ::<span class="ident">core</span>::<span class="ident">iter</span>::<span class="ident">Iterator</span> <span class="kw">for</span> <span class="ident">__Enum1</span><span class="op">&lt;</span><span class="ident">__T1</span>, <span class="ident">__T2</span><span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="ident">__T1</span>: ::<span class="ident">core</span>::<span class="ident">iter</span>::<span class="ident">Iterator</span>,
        <span class="ident">__T2</span>: ::<span class="ident">core</span>::<span class="ident">iter</span>::<span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">__T1</span> <span class="kw">as</span> ::<span class="ident">core</span>::<span class="ident">iter</span>::<span class="ident">Iterator</span><span class="op">&gt;</span>::<span class="ident">Item</span><span class="op">&gt;</span>,
    {
        <span class="kw">type</span> <span class="ident">Item</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">__T1</span> <span class="kw">as</span> ::<span class="ident">core</span>::<span class="ident">iter</span>::<span class="ident">Iterator</span><span class="op">&gt;</span>::<span class="ident">Item</span>;
        <span class="attribute">#[<span class="ident">inline</span>]</span>
        <span class="kw">fn</span> <span class="ident">next</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> ::<span class="ident">core</span>::<span class="ident">option</span>::<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Item</span><span class="op">&gt;</span> {
            <span class="kw">match</span> <span class="self">self</span> {
                <span class="ident">__Enum1</span>::<span class="ident">__T1</span>(<span class="ident">x</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">x</span>.<span class="ident">next</span>(),
                <span class="ident">__Enum1</span>::<span class="ident">__T2</span>(<span class="ident">x</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">x</span>.<span class="ident">next</span>(),
            }
        }
        <span class="attribute">#[<span class="ident">inline</span>]</span>
        <span class="kw">fn</span> <span class="ident">size_hint</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">usize</span>, ::<span class="ident">core</span>::<span class="ident">option</span>::<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>) {
            <span class="kw">match</span> <span class="self">self</span> {
                <span class="ident">__Enum1</span>::<span class="ident">__T1</span>(<span class="ident">x</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">x</span>.<span class="ident">size_hint</span>(),
                <span class="ident">__Enum1</span>::<span class="ident">__T2</span>(<span class="ident">x</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">x</span>.<span class="ident">size_hint</span>(),
            }
        }
    }

    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">__Enum1</span>::<span class="ident">__T1</span>(<span class="number">1</span>..<span class="number">10</span>),
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">__Enum1</span>::<span class="ident">__T2</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>()),
    }
}</pre></div>
</details>
<br>
<p><code>#[auto_enum]</code> can also parse nested arms/branches by using the <code>#[nested]</code>
attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">1</span>..<span class="number">10</span>,
        <span class="attribute">#[<span class="ident">nested</span>]</span>
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="kw">match</span> <span class="ident">x</span> {
            <span class="number">1</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
            <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">0</span>..<span class="op">=</span><span class="ident">x</span>,
        },
    }
}</pre></div>
<p><code>#[nested]</code> can be used basically in the same place as <code>#[auto_enum]</code>,
except that <code>#[nested]</code> cannot be used in functions.</p>
<h3 id="positions-where-auto_enum-can-be-used" class="section-header"><a href="#positions-where-auto_enum-can-be-used">Positions where <code>#[auto_enum]</code> can be used.</a></h3>
<p><code>#[auto_enum]</code> can be used in the following three places. However, since
<a href="https://github.com/rust-lang/rust/issues/15701">stmt_expr_attributes</a> and <a href="https://github.com/rust-lang/rust/issues/54727">proc_macro_hygiene</a> are not stabilized, you need
to use empty <code>#[auto_enum]</code> for functions except nightly.</p>
<ul>
<li>
<p>functions</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">func</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
        <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>()
    } <span class="kw">else</span> {
        <span class="number">0</span>..<span class="ident">x</span>
    }
}</pre></div>
</li>
<li>
<p>expressions</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">expr</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">0</span>..<span class="ident">x</span>,
    }
}</pre></div>
</li>
<li>
<p>let binding</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">let_binding</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">0</span>..<span class="ident">x</span>,
    };
    <span class="ident">iter</span>
}</pre></div>
</li>
</ul>
<h3 id="supported-syntax" class="section-header"><a href="#supported-syntax">Supported syntax</a></h3>
<ul>
<li>
<p><code>if</code> and <code>match</code></p>
<p>Wrap each branch with a variant.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="comment">// if</span>
<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">expr_if</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
        <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>()
    } <span class="kw">else</span> {
        <span class="number">0</span>..<span class="ident">x</span>
    }
}

<span class="comment">// match</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">expr_match</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">0</span>..<span class="ident">x</span>,
    };
    <span class="ident">iter</span>
}</pre></div>
</li>
<li>
<p><code>loop</code></p>
<p>Wrap each <code>break</code> with a variant. Nested loops and labeled <code>break</code> are
also supported.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">expr_loop</span>(<span class="kw-2">mut</span> <span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">loop</span> {
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
            <span class="kw">break</span> <span class="ident">x</span>..<span class="number">0</span>;
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">x</span> <span class="op">%</span> <span class="number">5</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
            <span class="kw">break</span> <span class="number">0</span>..<span class="op">=</span><span class="ident">x</span>;
        }
        <span class="ident">x</span> <span class="op">-</span><span class="op">=</span> <span class="number">1</span>;
    }
}</pre></div>
</li>
<li>
<p><code>return</code> (in functions)</p>
<p><code>#[auto_enum]</code> can parse the <code>return</code> in the scope.</p>
<p>This analysis is valid only when the return type is <code>impl Trait</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="comment">// return (in functions)</span>
<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">func</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
        <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>();
    }

    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&gt;</span> <span class="number">0</span> {
        <span class="number">0</span>..<span class="ident">x</span>
    } <span class="kw">else</span> {
        <span class="ident">x</span>..<span class="op">=</span><span class="number">0</span>
    }
}</pre></div>
</li>
<li>
<p><code>return</code> (in closures)</p>
<p><code>#[auto_enum]</code> can parse the <code>return</code> in the scope.</p>
<p>This analysis is valid only when the following two conditions are satisfied.</p>
<ul>
<li><code>#[auto_enum]</code> must be used directly for that closure (or the let binding of the closure).</li>
<li><code>?</code> operator not used in the scope.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="comment">// return (in closures)</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">closure</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="op">|</span><span class="ident">x</span><span class="op">|</span> {
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
            <span class="kw">return</span> <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>();
        }

        <span class="kw">if</span> <span class="ident">x</span> <span class="op">&gt;</span> <span class="number">0</span> {
            <span class="number">0</span>..<span class="ident">x</span>
        } <span class="kw">else</span> {
            <span class="ident">x</span>..<span class="op">=</span><span class="number">0</span>
        }
    };
    <span class="ident">f</span>(<span class="number">1</span>)
}</pre></div>
</li>
<li>
<p><code>?</code> operator (in functions)</p>
<p><code>#[auto_enum]</code> can parse the <code>?</code> operator in the scope.</p>
<p>This analysis is valid only when the return type is <code>Result&lt;T, impl Trait&gt;</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fmt</span>::{<span class="ident">Debug</span>, <span class="ident">Display</span>};

<span class="comment">// `?` operator (in functions)</span>
<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Debug</span>, <span class="ident">Display</span>)]</span>
<span class="kw">fn</span> <span class="ident">func</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="kw">impl</span> <span class="ident">Debug</span> <span class="op">+</span> <span class="ident">Display</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
        <span class="prelude-val">Err</span>(<span class="string">&quot;`x` is zero&quot;</span>)<span class="question-mark">?</span>;
    }

    <span class="comment">// The last branch of the function is not parsed.</span>
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
        <span class="prelude-val">Err</span>(<span class="ident">x</span>)<span class="question-mark">?</span>
    } <span class="kw">else</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>)
    }
}</pre></div>
<p><code>?</code> operator is expanded as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">match</span> <span class="ident">expr</span> {
    <span class="prelude-val">Ok</span>(<span class="ident">val</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">val</span>,
    <span class="prelude-val">Err</span>(<span class="ident">err</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">Enum</span>::<span class="ident">Veriant</span>(<span class="ident">err</span>)),
}</pre></div>
</li>
<li>
<p><code>?</code> operator (in closures)</p>
<p><code>#[auto_enum]</code> can parse the <code>?</code> operator in the scope.</p>
<p>However, <code>#[auto_enum]</code> must be used directly for that closure
(or the let binding of the closure).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fmt</span>::{<span class="ident">Debug</span>, <span class="ident">Display</span>};

<span class="comment">// `?` operator (in closures)</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">closure</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="kw">impl</span> <span class="ident">Debug</span> <span class="op">+</span> <span class="ident">Display</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Debug</span>, <span class="ident">Display</span>)]</span>
    <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="op">|</span><span class="ident">x</span><span class="op">|</span> {
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
            <span class="prelude-val">Err</span>(<span class="string">&quot;`x` is zero&quot;</span>)<span class="question-mark">?</span>
        }

        <span class="comment">// The last branch of the function is not interpreted as a branch.</span>
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
            <span class="prelude-val">Err</span>(<span class="ident">x</span>)<span class="question-mark">?</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Ok</span>(<span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>)
        }
    };
    <span class="ident">f</span>(<span class="number">1</span>)
}</pre></div>
</li>
<li>
<p>Block, unsafe block, method call, parentheses, and type ascription</p>
<p>The following expressions are recursively searched until an <code>if</code>, <code>match</code>,
<code>loop</code> or unsupported expression is found.</p>
<ul>
<li>blocks</li>
<li>unsafe blocks</li>
<li>method calls</li>
<li>parentheses</li>
<li>type ascriptions</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="comment">// block</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">expr_block</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    {
        <span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
            <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>()
        } <span class="kw">else</span> {
            <span class="number">0</span>..<span class="ident">x</span>
        }
    }
}

<span class="comment">// method call</span>
<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// Nightly does not need an empty attribute to the function.</span>
<span class="kw">fn</span> <span class="ident">expr_method</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
   <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>(),
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">0</span>..<span class="ident">x</span>,
    }.<span class="ident">map</span>(<span class="op">|</span><span class="ident">y</span><span class="op">|</span> <span class="ident">y</span> <span class="op">+</span> <span class="number">1</span>)
}

<span class="comment">// parentheses</span>
<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">expr_parentheses</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;</span> {
    (<span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> { <span class="prelude-val">Some</span>(<span class="number">0</span>).<span class="ident">into_iter</span>() } <span class="kw">else</span> { <span class="number">0</span>..<span class="ident">x</span> })
}</pre></div>
</li>
</ul>
<h3 id="expression-that-no-value-will-be-returned" class="section-header"><a href="#expression-that-no-value-will-be-returned">Expression that no value will be returned</a></h3>
<p>If the last expression of a branch is one of the following, it is
interpreted that no value will be returned (variant assignment is skipped).</p>
<ul>
<li><code>panic!(..)</code></li>
<li><code>unreachable!(..)</code></li>
<li><code>return</code></li>
<li><code>break</code></li>
<li><code>continue</code></li>
<li><code>None?</code></li>
<li><code>Err(..)?</code></li>
<li>Expression level marker (<code>marker!</code> macro).</li>
<li>An item definition.</li>
</ul>
<p>Also, if the branch contains <code>#[nested]</code>, it is interpreted as returning
an anonymous enum generated by <code>#[auto_enum]</code>, not a value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">1</span>..<span class="number">10</span>,
        <span class="number">1</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">panic</span><span class="macro">!</span>(), <span class="comment">// variant assignment is skipped</span>
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    }
}</pre></div>
<p>You can also skip that branch explicitly by <code>#[never]</code> attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">1</span>..<span class="number">10</span>,
        <span class="attribute">#[<span class="ident">never</span>]</span>
        <span class="number">1</span> <span class="op">=</span><span class="op">&gt;</span> <span class="kw">loop</span> {
            <span class="macro">panic</span><span class="macro">!</span>()
        },
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    }
}</pre></div>
<h3 id="expression-level-marker-marker-macro" class="section-header"><a href="#expression-level-marker-marker-macro">Expression level marker (<code>marker!</code> macro)</a></h3>
<p><code>#[auto_enum]</code> replaces <code>marker!</code> macros with variants.
If values of two or more are specified by <code>marker!</code> macros, <code>#[auto_enum]</code>
can be used for unsupported expressions and statements.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
        <span class="kw">return</span> <span class="ident">x</span>..<span class="op">=</span><span class="number">0</span>;
    }
    <span class="macro">marker</span><span class="macro">!</span>(<span class="number">1</span>..<span class="number">10</span>)
}</pre></div>
<p>The default name of the macro is <code>&quot;marker&quot;</code>, but you can change it by
<code>marker</code> option.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">marker</span> <span class="op">=</span> <span class="ident">bar</span>, <span class="ident">Iterator</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">0</span> {
        <span class="kw">return</span> <span class="ident">x</span>..<span class="op">=</span><span class="number">0</span>;
    }
    <span class="macro">bar</span><span class="macro">!</span>(<span class="number">1</span>..<span class="number">10</span>)
}</pre></div>
<h2 id="rust-nightly" class="section-header"><a href="#rust-nightly">Rust Nightly</a></h2>
<p>When using <code>#[auto_enum]</code> for expressions and statements, <code>#[auto_enum]</code> for
function is unnecessary.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Add this to your crate root:</span>
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">proc_macro_hygiene</span>, <span class="ident">stmt_expr_attributes</span>)]</span></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> {
    <span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Iterator</span>)]</span>
    <span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">1</span>..<span class="number">10</span>,
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    };

    <span class="ident">iter</span>.<span class="ident">fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">sum</span>, <span class="ident">x</span><span class="op">|</span> <span class="ident">sum</span> <span class="op">+</span> <span class="ident">x</span>)
}</pre></div>
<p>You can also return closures.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Add this to your crate root:</span>
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">fn_traits</span>, <span class="ident">unboxed_closures</span>)]</span></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Fn</span>)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">bool</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Fn</span>(<span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> {
    <span class="kw">if</span> <span class="ident">x</span> { <span class="op">|</span><span class="ident">y</span><span class="op">|</span> <span class="ident">y</span> <span class="op">+</span> <span class="number">1</span> } <span class="kw">else</span> { <span class="op">|</span><span class="ident">z</span><span class="op">|</span> <span class="ident">z</span> <span class="op">-</span> <span class="number">1</span> }
}</pre></div>
<h2 id="enum_derive" class="section-header"><a href="#enum_derive"><code>#[enum_derive]</code></a></h2>
<p><code>#[enum_derive]</code> implements the supported traits and passes unsupported
traits to <code>#[derive]</code>.</p>
<p>If you want to use traits that are not supported by <code>#[enum_derive]</code>, you
can use another crate that provides <code>proc_macro_derive</code>, or you can define
<code>proc_macro_derive</code> yourself(<a href="https://github.com/taiki-e/derive_utils">derive_utils</a> probably can help it).</p>
<p>Basic usage of <code>#[enum_derive]</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">enum_derive</span>;

<span class="comment">// `#[enum_derive]` implements `Iterator`, and `#[derive]` implements `Clone`.</span>
<span class="attribute">#[<span class="ident">enum_derive</span>(<span class="ident">Iterator</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">enum</span> <span class="ident">Foo</span><span class="op">&lt;</span><span class="ident">A</span>, <span class="ident">B</span><span class="op">&gt;</span> {
    <span class="ident">A</span>(<span class="ident">A</span>),
    <span class="ident">B</span>(<span class="ident">B</span>),
}</pre></div>
<p><code>#[enum_derive]</code> adds the dependency of the specified trait if it is not
specified.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">enum_derive</span>;

<span class="comment">// `#[enum_derive]` implements `Iterator` and `ExactSizeIterator`.</span>
<span class="attribute">#[<span class="ident">enum_derive</span>(<span class="ident">ExactSizeIterator</span>)]</span>
<span class="kw">enum</span> <span class="ident">Foo</span><span class="op">&lt;</span><span class="ident">A</span>, <span class="ident">B</span><span class="op">&gt;</span> {
    <span class="ident">A</span>(<span class="ident">A</span>),
    <span class="ident">B</span>(<span class="ident">B</span>),
}</pre></div>
<h2 id="supported-traits" class="section-header"><a href="#supported-traits">Supported traits</a></h2>
<p>Some traits support is disabled by default.
Note that some traits have aliases.</p>
<p><em>When using features that depend on unstable APIs, the <code>unstable</code> feature must be explicitly enabled</em></p>
<h3 id="stdcore-libraries" class="section-header"><a href="#stdcore-libraries">[std|core] libraries</a></h3>
<p><code>[std|core]::iter</code></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/iterator.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/DoubleEndedIterator.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html"><code>ExactSizeIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/ExactSizeIterator.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.FusedIterator.html"><code>FusedIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/FusedIterator.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Extend.html"><code>Extend</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/extend.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.TrustedLen.html"><code>TrustedLen</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/iter/TrustedLen.md">generated code</a> <em>(requires <code>&quot;trusted_len&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
</ul>
<p><em>See also <a href="https://github.com/taiki-e/iter-enum">iter-enum</a> crate.</em></p>
<p><code>[std|core]::future</code></p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/std/future/trait.Future.html"><code>Future</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/future.md">generated code</a></li>
</ul>
<p><em>See also <a href="https://github.com/taiki-e/futures-enum">futures-enum</a> crate.</em></p>
<p><code>std::io</code> <em>(requires <code>&quot;std&quot;</code> crate feature)</em></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> (alias: <code>io::Read</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/io/read.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> (alias: <code>io::BufRead</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/io/BufRead.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> (alias: <code>io::Write</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/io/write.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/io/trait.Seek.html"><code>Seek</code></a> (alias: <code>io::Seek</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/io/seek.md">generated code</a></li>
</ul>
<p><em>See also <a href="https://github.com/taiki-e/io-enum">io-enum</a> crate.</em></p>
<p><code>[std|core]::ops</code></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.RangeBounds.html"><code>RangeBounds</code></a> <em>(requires <code>&quot;ops&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a> <em>(requires <code>&quot;fn_traits&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> <em>(requires <code>&quot;fn_traits&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> <em>(requires <code>&quot;fn_traits&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
<li><a href="https://doc.rust-lang.org/nightly/std/ops/trait.Generator.html"><code>Generator</code></a> <em>(requires <code>&quot;generator_trait&quot;</code> and <code>&quot;unstable&quot;</code> crate features)</em></li>
</ul>
<p><code>[std|core]::convert</code></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> <em>(requires <code>&quot;convert&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a> <em>(requires <code>&quot;convert&quot;</code> crate feature)</em></li>
</ul>
<p><code>[std|core]::fmt</code></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> (alias: <code>fmt::Debug</code>) - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/debug.md">generated code</a></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> (alias: <code>fmt::Display</code>)</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Binary.html"><code>fmt::Binary</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.LowerExp.html"><code>fmt::LowerExp</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.LowerHex.html"><code>fmt::LowerHex</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Octal.html"><code>fmt::Octal</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>fmt::Pointer</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.UpperExp.html"><code>fmt::UpperExp</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.UpperHex.html"><code>fmt::UpperHex</code></a> <em>(requires <code>&quot;fmt&quot;</code> crate feature)</em></li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Write.html"><code>fmt::Write</code></a></li>
</ul>
<p><code>std::error</code> <em>(requires <code>&quot;std&quot;</code> crate feature)</em></p>
<ul>
<li><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/std/error.md">generated code</a></li>
</ul>
<h3 id="external-libraries" class="section-header"><a href="#external-libraries">External libraries</a></h3>
<p>You can add support for external library by activating the each crate feature.</p>
<p><a href="https://github.com/rust-lang-nursery/futures-rs"><code>futures(v0.3)</code></a> <em>(requires <code>&quot;futures03&quot;</code> or <code>&quot;futures&quot;</code> crate feature)</em></p>
<ul>
<li><a href="https://docs.rs/futures/0.3/futures/stream/trait.Stream.html"><code>futures::Stream</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/stream.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/sink/trait.Sink.html"><code>futures::Sink</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/sink.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/io/trait.AsyncRead.html"><code>futures::AsyncRead</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/AsyncRead.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/io/trait.AsyncWrite.html"><code>futures::AsyncWrite</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/AsyncWrite.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/io/trait.AsyncSeek.html"><code>futures::AsyncSeek</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/AsyncSeek.md">generated code</a></li>
<li><a href="https://docs.rs/futures/0.3/futures/io/trait.AsyncBufRead.html"><code>futures::AsyncBufRead</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/futures/AsyncBufRead.md">generated code</a></li>
</ul>
<p><em>See also <a href="https://github.com/taiki-e/futures-enum">futures-enum</a> crate.</em></p>
<p><a href="https://github.com/rust-lang-nursery/futures-rs"><code>futures(v0.1)</code></a> <em>(requires <code>&quot;futures01&quot;</code> crate feature)</em></p>
<ul>
<li><a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>futures01::Future</code></a></li>
<li><a href="https://docs.rs/futures/0.1/futures/stream/trait.Stream.html"><code>futures01::Stream</code></a></li>
<li><a href="https://docs.rs/futures/0.1/futures/sink/trait.Sink.html"><code>futures01::Sink</code></a></li>
</ul>
<p><a href="https://github.com/rayon-rs/rayon"><code>rayon</code></a> <em>(requires <code>&quot;rayon&quot;</code> crate feature)</em></p>
<ul>
<li><a href="https://docs.rs/rayon/1.0/rayon/iter/trait.ParallelIterator.html"><code>rayon::ParallelIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/rayon/ParallelIterator.md">generated code</a></li>
<li><a href="https://docs.rs/rayon/1.0/rayon/iter/trait.IndexedParallelIterator.html"><code>rayon::IndexedParallelIterator</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/rayon/IndexedParallelIterator.md">generated code</a></li>
<li><a href="https://docs.rs/rayon/1.0/rayon/iter/trait.ParallelExtend.html"><code>rayon::ParallelExtend</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/rayon/ParallelExtend.md">generated code</a></li>
</ul>
<p><a href="https://github.com/serde-rs/serde"><code>serde</code></a> <em>(requires <code>&quot;serde&quot;</code> crate feature)</em></p>
<ul>
<li><a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>serde::Serialize</code></a> - <a href="https://github.com/taiki-e/auto_enums/blob/master/docs/supported_traits/external/serde/serialize.md">generated code</a></li>
</ul>
<p><a href="https://github.com/tokio-rs/tokio"><code>tokio(v0.2)</code></a> <em>(requires <code>&quot;tokio02&quot;</code> crate feature)</em></p>
<ul>
<li><a href="https://docs.rs/tokio/0.2/tokio/io/trait.AsyncRead.html"><code>tokio02::AsyncRead</code></a></li>
<li><a href="https://docs.rs/tokio/0.2/tokio/io/trait.AsyncWrite.html"><code>tokio02::AsyncWrite</code></a></li>
<li><a href="https://docs.rs/tokio/0.2/tokio/io/trait.AsyncSeek.html"><code>tokio02::AsyncSeek</code></a></li>
<li><a href="https://docs.rs/tokio/0.2/tokio/io/trait.AsyncBufRead.html"><code>tokio02::AsyncBufRead</code></a></li>
</ul>
<p><a href="https://github.com/tokio-rs/tokio/tree/v0.1.x"><code>tokio(v0.1)</code></a> <em>(requires <code>&quot;tokio01&quot;</code> crate feature)</em></p>
<ul>
<li><a href="https://docs.rs/tokio/0.1/tokio/io/trait.AsyncRead.html"><code>tokio01::AsyncRead</code></a></li>
<li><a href="https://docs.rs/tokio/0.1/tokio/io/trait.AsyncWrite.html"><code>tokio01::AsyncWrite</code></a></li>
</ul>
<h3 id="static-methods" class="section-header"><a href="#static-methods">Static methods</a></h3>
<p>These don't derive traits, but derive static methods instead.</p>
<ul>
<li>
<p><code>Transpose</code> <em>(requires <code>&quot;transpose_methods&quot;</code> crate feature)</em> - this derives the following conversion methods.</p>
<ul>
<li>
<p><code>transpose</code> - convert from <code>enum&lt;Option&lt;T1&gt;,..&gt;</code> to <code>Option&lt;enum&lt;T1,..&gt;&gt;</code></p>
</li>
<li>
<p><code>transpose</code> - convert from <code>enum&lt;Result&lt;T1, E1&gt;,..&gt;</code> to <code>Result&lt;enum&lt;T1,..&gt;, enum&lt;E1,..&gt;&gt;</code></p>
</li>
<li>
<p><code>transpose_ok</code> - convert from <code>enum&lt;Result&lt;T1, E&gt;,..&gt;</code> to <code>Option&lt;enum&lt;T1,..&gt;, E&gt;</code></p>
<p>Examples:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">fs</span>, <span class="ident">io</span>, <span class="ident">path</span>::<span class="ident">Path</span>};

<span class="attribute">#[<span class="ident">auto_enum</span>(<span class="ident">Transpose</span>, <span class="ident">Write</span>)]</span>
<span class="kw">fn</span> <span class="ident">output_stream</span>(<span class="ident">file</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">Path</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="kw">impl</span> <span class="ident">io</span>::<span class="ident">Write</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">file</span> {
        <span class="prelude-val">Some</span>(<span class="ident">f</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">fs</span>::<span class="ident">File</span>::<span class="ident">create</span>(<span class="ident">f</span>),
        <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(<span class="ident">io</span>::<span class="ident">stdout</span>()),
    }.<span class="ident">transpose_ok</span>()
}</pre></div>
</li>
<li>
<p><code>transpose_err</code> - convert from <code>enum&lt;Result&lt;T, E1&gt;,..&gt;</code> to <code>Result&lt;T, enum&lt;E1,..&gt;&gt;</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="crate-features" class="section-header"><a href="#crate-features">Crate Features</a></h2>
<ul>
<li>
<p><code>std</code></p>
<ul>
<li>Enabled by default.</li>
<li>Enable to use <code>std</code> library's traits.</li>
</ul>
</li>
<li>
<p><code>ops</code></p>
<ul>
<li>Disabled by default.</li>
<li>Enable to use <code>[std|core]::ops</code>'s <code>Deref</code>, <code>DerefMut</code>, <code>Index</code>, <code>IndexMut</code>, and <code>RangeBounds</code> traits.</li>
</ul>
</li>
<li>
<p><code>convert</code></p>
<ul>
<li>Disabled by default.</li>
<li>Enable to use <code>[std|core]::convert</code>'s <code>AsRef</code> and <code>AsMut</code> traits.</li>
</ul>
</li>
<li>
<p><code>fmt</code></p>
<ul>
<li>Disabled by default.</li>
<li>Enable to use <code>[std|core]::fmt</code>'s traits other than <code>Debug</code>, <code>Display</code> and <code>Write</code>.</li>
</ul>
</li>
<li>
<p><code>type_analysis</code></p>
<ul>
<li>
<p>Disabled by default.</p>
</li>
<li>
<p>Analyze return type of function and <code>let</code> binding.</p>
<p><strong>Note that this feature is still experimental.</strong></p>
<p>Examples:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">auto_enums</span>::<span class="ident">auto_enum</span>;

<span class="attribute">#[<span class="ident">auto_enum</span>]</span> <span class="comment">// there is no need to specify std library&#39;s traits</span>
<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">x</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">Iterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">x</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="number">1</span>..<span class="number">10</span>,
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">10</span>].<span class="ident">into_iter</span>(),
    }
}</pre></div>
<p>Please be careful if you return another traits with the same name.</p>
</li>
</ul>
</li>
<li>
<p><code>transpose_methods</code></p>
<ul>
<li>Disabled by default.</li>
<li>Enable to use <code>transpose*</code> methods.</li>
</ul>
</li>
</ul>
<h3 id="using-external-libraries-disabled-by-default" class="section-header"><a href="#using-external-libraries-disabled-by-default">Using external libraries (disabled by default)</a></h3>
<ul>
<li>
<p><code>futures</code> - <a href="https://github.com/rust-lang-nursery/futures-rs">futures(v0.3)</a> <em>(requires <code>&quot;unstable&quot;</code> crate feature)</em></p>
</li>
<li>
<p><code>futures01</code> - <a href="https://github.com/rust-lang-nursery/futures-rs">futures(v0.1)</a></p>
</li>
<li>
<p><code>rayon</code> - <a href="https://github.com/rayon-rs/rayon">rayon</a></p>
</li>
<li>
<p><code>serde</code> - <a href="https://github.com/serde-rs/serde">serde</a></p>
</li>
</ul>
<h3 id="enable-unstable-features-of-stdcore-libraries-disabled-by-default-requires-unstable-crate-feature" class="section-header"><a href="#enable-unstable-features-of-stdcore-libraries-disabled-by-default-requires-unstable-crate-feature">Enable unstable features of [std|core] libraries (disabled by default, requires <code>&quot;unstable&quot;</code> crate feature)</a></h3>
<p>For these features, you need to enable the unstable feature gate of the same name.</p>
<p>Note that support for these features are unstable and may cause incompatible changes between patch versions.</p>
<ul>
<li>
<p><a href="https://github.com/rust-lang/rust/issues/43122"><code>generator_trait</code></a> - Enable to use <code>[std|core]::ops::Generator</code> trait.</p>
</li>
<li>
<p><a href="https://github.com/rust-lang/rust/issues/29625"><code>fn_traits</code></a> - Enable to use <code>[std|core]::ops</code>'s <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> traits.</p>
</li>
<li>
<p><a href="https://github.com/rust-lang/rust/issues/37572"><code>trusted_len</code></a> - Enable to use <code>[std|core]::iter::TrustedLen</code> trait.</p>
</li>
</ul>
<h2 id="known-limitations" class="section-header"><a href="#known-limitations">Known limitations</a></h2>
<ul>
<li>
<p>There needs to explicitly specify the trait to be implemented (<code>type_analysis</code> crate feature reduces this limitation).</p>
</li>
<li>
<p>There needs to be marker macros for unsupported expressions.</p>
</li>
</ul>
</div><h2 id='attributes' class='section-header'><a href="#attributes">Attribute Macros</a></h2>
<table><tr class='module-item'><td><a class="attr" href="attr.auto_enum.html" title='auto_enums::auto_enum attr'>auto_enum</a></td><td class='docblock-short'><p>An attribute macro for to allow multiple return types by automatically generated enum.</p>
</td></tr><tr class='module-item'><td><a class="attr" href="attr.enum_derive.html" title='auto_enums::enum_derive attr'>enum_derive</a></td><td class='docblock-short'><p>An attribute macro like a wrapper of <code>#[derive]</code>, implementing
the supported traits and passing unsupported traits to <code>#[derive]</code>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "auto_enums";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>